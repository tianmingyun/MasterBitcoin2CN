现在，我们来看看比特币作为一个应用平台，尝试进一步加强理解。 现在很多人使用“blockchain”这个词来表示任何分享了比特币设计原则的应用平台。 该术语经常被滥用，并被应用于许多不能提供比特币区块链主要功能的事情。在本章中，我们将介绍比特币区块链作为应用平台所提供的功能。 我们将考虑应用程序构建原语，构成任何块链应用程序的构建块。 我们将研究使用这些原语的几个重要应用程序，例如彩色币，付款（状态）渠道和路由支付渠道（闪电网络）。

# 12.1介绍

比特币系统被设计为分布式的货币和支付系统。 然而，它的大部分功能来自可用于更广泛应用的较低级别的结构。 比特币不是用帐户，用户，余额和付款等组件构建的。 相反，我们在\[交易\]章节中看到，它使用具有低级加密功能的交易脚本语言。 就像这些源自基本原语的账户，余额和付款的更高层次的概念一样，许多其他复杂的应用也是如此。 因此，比特币区块链可以成为向诸如智能合同等应用程序提供信任服务的应用平台，远远超出了数字货币和支付的原始目的。

# 12.2构建块（基元）

当运行正常且长期运行时，比特币系统提供了一定的保证，可以作为构建块来创建应用程序。 

这些包括：

**没有双重支出**比特币分散共识算法的最根本保证是确保UTXO不会花费两次。

**不可改变性**一旦交易被记录在区块中，并且随后的区块中添加了足够的工作，交易数据就变得不可更改。 不可改变性是由能量进行承保的，因为重写区块链需要有真实的能源支出才能产生工作证明。 所需的能量以及由此带来的不可变性的程度随着在包含交易的区块之上承诺的工作量而增加。

**中立**去中心化的比特币网络传播有效的交易，而不管这些交易的来源或内容如何。 这意味着任何人都可以支付足够的费用创建有效的交易，并相信他们可以随时传输该交易并将其包含在区块链中。

**安全时间戳**共识规则拒绝任何时间戳距离现在太远（过去和将来）的块。 这可以确保块上的时间戳可以被信任。 块上的时间戳意味着对所有包含的交易的输入的未花费之前的保证。

**授权**在去中心化网络中验证的数字签名提供授权保证。没有脚本中隐含的私钥的持有人的授权，包含数字签名要求的脚本就不能被执行。

**审计能力**所有交易都是公开的，可以被审计。 所有的交易和交易所属的区块都可以链接到一个不间断的区块链并最终链接到创始区块。

**会计**在任何交易中（coinbase交易除外），输入的金额等于输出的金额加上交易费用。 不可能在交易中创建或销毁比特币数额。 输出不能超过输入。**永不过期**有效的交易永远不会过期。 如果今天有效，它将在不久的将来有效，只要输入仍然没有被花费，共识规则没有改变。**完整性**使用SIGHASH\_ALL签名的比特币交易或由另一个SIGHASH类型签署的交易的部分不能在签名还有效的情况下被修改，从而导致交易本身无效。**交易原子性**比特币交易是原子的（译者注：原子性是指交易要么全部执行，要么完全不执行，不存在中间状态）。 它们或者是有效的和经过确认的（挖矿），或者不是。 不存在挖矿出交易的一部分，交易也不存在中间状态。 在任何时间点，交易要么被挖出，要么不是，不存在中间状态。**离散（不可分割）价值单位**交易输出是离散和不可分割的价值单位。 他们或者整体被花费或者整体没有花费，被可以全部用完或不用了。 他们不能分开或者部分被花费。**法定人数**脚本中的多重签名约束规定了多权限方案中的预定义的授权定额。 M-of-N要求由共识规则执行。**Timelock/老化**包含相对或绝对时间锁的任何脚本语句只能在其时间超过指定时间后执行。**复制**区块链的去中心化存储确保了在交易开采之后，经过充分的确认，它被复制到整个网络上，并且经受得起电力损失，数据丢失等的影响。**伪造保护**每笔交易只能花费现有的经过验证的输出。不可能创建或伪造价值。**一致性**在没有矿工分区的情况下，根据记录的深度，记录在块状块中的块将受限于被重新组织或以指数级降低的可能性。一旦被记录在深层，改变所需的计算和能量将大到不可行的程度。**记录外部状态**交易可以通过OP\_RETURN提交一个值，表示外部状态机中的状态转换。**可预测发行**发行速度是可预测的，发行总量也是可以预测的，不到2100万比特币。上述构建块区的列表并不完整，还会有新功能都被介绍添加到比特币中。

# 12.3源于构建区块的应用

由比特币提供的构建区块是可用于编写应用程序的可信平台组成部分。 以下是今天在用的应用程序及其使用的构建区块的一些示例：Proof-of-Existence（Digital Notary）不可篡改性+时间戳+永久性。数字指纹可以通过一个交易提交给区块链，证明记录存档的时间（Timestamp）。数字指纹不能在事后修改（Immutability），证据将被永久存储（Durability）。

Kickstarter（Lighthouse）一致性+原子性+可信。如果您发起众筹活动的一个输入和输出（Integrity），别人可以参与众筹，但在目标（output value）完成之前（Consistency）之前，这笔钱不能被花费出去（Atomicity）。

Payment Channels控制法定人数+时间锁+不能双重支付+永不过期+审查抵抗+授权。具有可以作为付款渠道的“结算”交易（Nonexpiration）的时间锁（Timelock）的多重签名，如果设定为2-2法定人数（Quorum），那么可以由任何一方授权（Authorization）在任何情况下（Censorship Resistance）进行花费。然后双方可以在更短的时间锁（Timelock）创建双重支出（\(No Double-Spend）结算的确认交易。（译者注：本段原文如下：Quorum of Control + Timelock + No Double Spend + Nonexpiration + Censorship Resistance + Authorization. A multisig 2-of-2 \(Quorum\) with a timelock \(Timelock\) used as the "settlement" transaction of a payment channel can be held \(Nonexpiration\) and spent whenever \(Censorship Resistance\) by either party \(Authorization\). The two parties can then create commitment transactions that double-spend \(No Double-Spend\) the settlement on a shorter timelock \(Timelock\).）

# 12.4染色币（Colored Coins）

我们将讨论的第一个块链应用是染色币。染色币是指使用比特币交易来记录除比特币之外的外在资产的创建，所有权和转让的一组类似技术。 “外在”我们是指这些资产不直接存储在比特币区块上，而不是指比特币本身，因为比特币是本身就是这个区块链的固有资产。染色币用于跟踪第三方持有的数字资产和实物资产，并通过染色币所有权证书进行交易。 数字资产染色币可以代表无形资产，如股票证书，许可证，虚拟财产（游戏项目）或大多数任何形式的许可知识产权（商标，版权等）。 有形资产染色币可以代表商品（黄金，白银，石油），土地所有权，汽车，船只，飞机等所有权。该术语源于“着色”或标记比特币的名义数量的想法，例如，1聪，用来表示比特币价值本身以外的东西。作为一个类比，我们举例1美元的钞票，说：“这是ACME的股票证书”，或者“这个钞票可以兑换1盎司的银”，然后使用这个1美元钞票与作为其他资产权益证明进行交易。染色币的第一次实施，名为“基于增强填充订单的着色”或“EPOBC”，将外部资产分配给1聪输出。这样，这是一个真正的“染色币”，因为每个资产被添加为1聪的属性（颜色）。染色币的最新实施使用OP\_RETURN脚本操作码将交易中的元数据与将元数据与特定资产相关联的外部数据存储结合在一起。今天染色币的两个最突出的实现是 Open Assets和Colu的染色币。这两个系统使用不同的方法来染色，并不兼容。在一个系统中创建的染色币在其他系统中无法看到或使用。

## 12.4.1使用染色币

染色币被创建，转移，并且通常用特殊的钱包来查看，这个钱包可以解释为将染色币协议元数据附加到比特币交易中。 必须特别注意避免在常规的比特币钱包中使用染色币相关的密钥，因为常规钱包可能会破坏元数据。 同样地，染色币也不应该被发送到由常规钱包管理的地址，而只能发送到由染色币能够识别的钱包管理的地址。Colu和Open Assets这两个系统都使用特殊的染色币地址来减轻这种风险，并确保染色币不会发送到不能识别的钱包。染色币对大多数通用的blockchain浏览器也是不可见的。 相反，您必须使用染色币浏览器来解释染色币交易的元数据。Open Assets兼容的钱包应用程序和区块链浏览器可以在[coinprism](https://www.coinprism.info/)查找。可以在[专门的Blockchain Explorer](http://coloredcoins.org/explorer/)中找到Colu染色币兼容的钱包应用程序和区块链探索器。Copay钱包插件可以在[Colored Coins Copay Addon](http://coloredcoins.org/colored-coins-copay-addon/)中找到。

## 12.4.2发行染色币

每个染色币的实现都有不同的创造染色币的方法，但它们都提供类似的功能。创造染色币资产的过程称为发行。初始交易中，发行交易将资产登记在比特币块上，并创建用于引用资产的资产ID。一旦发行，资产可以使用转账交易在地址之间转账。作为染色币发行的资产可以有多种属性。它们可以是可分割的或不可分割的，这意味着转账中的资产量可以是整数（比如5）或具有十进制细分（比如4.321）。资产也可以固定发行，意思是一次只发行一次，也可以重新发行，后者意味着初始发行后原始发行人可以发行新资产单位。最后，一些染色币可以分红，允许将比特币付款按照有权成比例分配给染色币资产的所有者。

## 12.4.3染色币交易

给染色币交易提供意义的元数据通常使用OP\_RETURN操作码存储在其中一个输出中。不同颜色的硬币协议对OP\_RETURN数据的内容使用不同的编码。包含OP\_RETURN的输出称为标记输出。输出的顺序和标记输出的位置在染色币协议中可能具有特殊含义。例如，在Open Assets中，标记输出之前的任何输出都代表资产发行。标记输出后的任何输出表示资产转账。标记输出通过引用其在交易中的顺序将特定值和颜色分配给其他输出。在Colored Coins \(Colu\)中，通过比较，标记输出编码一个确定元数据如何解释的操作码。操作码0x01至0x0F表示发行交易。发行操作码通常后面是资产ID或可用于从外部来源（例如bittorrent）检索资产信息的其他标识符。操作码0x10到​​0x1F表示传输交易。转账交易元数据包含简单的脚本，通过参考其索引将特定数量的资产从输入转账到输出。因此，输入和输出的排序对脚本的解释很重要。如果元数据太长而不能适应OP\_RETURN，则染色币协议可能会使用其他“技巧”在交易中存储元数据。示例包括将元数据放在兑换脚本中，其次是OP\_DROP操作码，以确保脚本忽略元数据。所使用的另一种机制是1-N 多重签名脚本，其中只有第一个公钥是可以花费输出的真实公钥，并且随后的“密钥”被编码的元数据替代。为了正确解释染色币交易中的元数据，您必须使用兼容的钱包或块资源管理器。否则，该交易看起来像一个具有OP\_RETURN输出的“正常”比特币交易。例如，我使用染色币创建并发行了MasterBTC资产。 “MasterBTC”代表了可以获取本书免费拷贝的兑换码。这些兑换码可以使用染色币兼容的钱包进行转让，交易和兑换。对于这个特定的例子，我使用了[https://coinprism.info](https://coinprism.info)的钱包和浏览器，它使用了Open Assets染色币协议。

下图12-1显示使用Coinprism块浏览器的发行交易：[https://www.coinprism.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec](https://www.coinprism.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec)

![](http://upload-images.jianshu.io/upload_images/1785959-5e143aa41aae429d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)正如你所看到的那样，coinprism显示了发行的20个“精通比特币的免费拷贝”，短名称为MasterBTC的资产，发给了一个特殊的彩色硬币地址：akTnsDt5uzpioRST76VFRQM8q8sBFnQiwcx**警告**发送到该地址的任何资金或染色币将永远丢失。 不要发送到这个示例地址！发行交易的交易ID是“正常”比特币交易ID。下图12-2显示在区块浏览器中不会对染色币进行解码的同一笔交易。 我们将使用blockchain.info：[https://blockchain.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec](https://blockchain.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec)

![](http://upload-images.jianshu.io/upload_images/1785959-bbb428948063d223.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)正如你所看到的，blockchain.info不认为这是一个染色币交易。 事实上，它以红色字母表示“无法解码输出地址”的第二个输出。如果您在该屏幕上选择“显示脚本和coinbase”，可以看到有关交易的更多详细信息\(下图12-3\)

![](http://upload-images.jianshu.io/upload_images/1785959-40c0c43f9dc8f9de.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)再次，blockchain.info并不能理解第二个输出。 它以红色字母表示“奇怪”。 但是，我们可以看到，标记输出中的一些元数据是可读的：OP\_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559\(decoded\) "OAu=[https://cpr.sm/FoykwrH6UY](https://cpr.sm/FoykwrH6UY)让我们使用bitcoin-cli检索交易：$ bitcoin-cli decoderawtransaction`bitcoin-cli getrawtransaction 10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec`剥离其余的交易，第二个输出如下所示：{"value": 0.00000000,"n": 1,"scriptPubKey": "OP\_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559"}前缀4F41表示字母“OA”，代表“Open Assets”，并帮助我们确定以下是由Open Assets协议定义的元数据。 以下ASCII编码的字符串是指向资产定义的链接：u=[https://cpr.sm/FoykwrH6UY](https://cpr.sm/FoykwrH6UY)如果我们检索此URL，我们将获得JSON编码的资产定义，如下所示：{"asset\_ids": \[

```
"AcuRVsoa81hoLHmVTNXrRD8KpTqUXeqwgH"
```

\],"contract\_url": null,"name\_short": "MasterBTC","name": "Free copy of \"Mastering Bitcoin\"","issuer": "Andreas M. Antonopoulos","description": "This token is redeemable for a free copy of the book \"Mastering Bitcoin\"","description\_mime": "text/x-markdown; charset=UTF-8","type": "Other","divisibility": 0,"link\_to\_website": false,"icon\_url": null,"image\_url": null,"version": "1.0"}

# 12.5合约币（Counterparty）

合约币是在比特币之上建立的协议层。与“染色币”类似的“合约币协议”提供了创建和交易虚拟资产和代币的能力。此外，合约币提供了分散的资产交换。合约币还在实施基于Ethereum虚拟机（EVM）的智能合同。像染色币协议一样，合约币使用OP\_RETURN操作码或1-N多重签名地址将元数据嵌入到比特币交易中，该地址用于代替公共密钥进行元数据编码。使用这些机制，合约币实现了在比特币交易中编码的协议层。额外的协议层可以由合约币理解的应用程序来解释，如钱包和区块链浏览器，或使用合约币库（library）构建的任何应用程序。

合约币可以依次用作其他应用程序和服务的平台。例如，Tokenly是一个建立在交易合约币之上的平台，允许内容创作者，艺术家和公司发行表达数字所有权的代币，并可用于租赁，访问，交易或购买内容，产品和服务。利用交易合约币的其他应用包括游戏（Spells of Genesis）和网格计算项目（\(Folding Coin）。更过内容参见[https://counterparty.io](https://counterparty.io/)。开源项目可以在[https://github.com/CounterpartyXCP](https://github.com/CounterpartyXCP)寻找。

# 12.6支付通道和状态通道

支付通道是在比特币块之外交换双方之间的比特币交易的无信任机制。这些交易，如果在比特币块上结算，则是有效的，但是相反在链下，就成为最终进行批量结算的期票。由于交易未结算，因此可以在没有通常的结算延迟的情况下进行交换，从而允许极高的交易吞吐量，低（亚毫秒）的延迟和精细（satoshi级）粒度。

实际上，通道一词是一个比喻。状态通道是区块链外，由双方之间的交流状态代表的虚拟结构。本身没有“渠道”，底层数据传输机制不是渠道。我们使用术语通道来表示链外双方之间的关系和共享状态。

为了进一步解释这个概念，想一想TCP流。从高级协议的角度来看，它是一个通过互联网连接两个应用程序的“socket”。但是，如果您查看网络流量，则TCP流只是IP数据包的虚拟通道。 TCP流的每个端点排序并组装IP包以产生字节流的错觉。实际上在背后，这是所有断开的分散的数据包。同样，支付通道只是一系列交易。如果妥善排序和连接，即使您不信任通道的另一方，也可以创建可以信任的可兑换的债务。

在本节中，我们将介绍各种支付通道。首先，我们将研究用于构建计量小额支付服务（如流媒体视频）的单向（单向）支付通道的机制。然后，我们将扩大这一机制，引入双向付费渠道。最后，我们将首先在雷电网络中提出，将路由网络中的双向通道连接到端到端形成多跳通道。

支付通道是状态通道的更广泛概念的一部分，代表了链下状态的变化，通过最终的结算得到保障。支付通道是状态被改变的状态通道，是虚拟货币的余额。

## 12.6.1状态通道基本概念和术语

通过在链上锁定共享状态的交易在两方之间建立状态通道。这被称为资金交易或锚点交易。这个单一的交易必须传送到网络并开始挖矿建立通道。在支付通道的示例中，锁定状态是通道的初始余额（以货币计）。

然后双方交换签署的交易，称为承诺交易，改变初始状态。这些交易是有效的交易，因为它们可以被任何一方提交以结算，但是相反在链下，可以由任何一方延迟通道关闭。状态更新可以由每方一样快速创建，签署和传送交易给另一方。实际上，这意味着可以每秒进行数千个交易。

当交换承诺交易时，双方也可使以前的状态无效，以至于最新的承诺交易总是唯一可以赎回的承诺交易。这样可以防止任何一方通过单方面关闭通道进行欺骗，使用以前过期的状态而不是当前的状态这样更有利于自己。我们将在本章的其余部分中研究可用于使先前状态无效的各种机制。

最后，通道可以合作关闭，通过向区块链提交最后的结算交易，或者单方面由任何一方提交最后承诺交易到链上。如果一方意外断开连接，则需要单方面关闭选项。结算交易代表通道的最终状态，并在链上进行结算。

在通道的整个生命周期中，只有两个交易需要提交给链上进行挖矿：资金和结算交易。在这两个状态之间，双方可以交换任何其他人永远不会看到的任何数量的承诺交易，也不会提交到链上。下图12-4说明了Bob和Alice之间的支付通道，显示了资金，承诺和结算交易。

![](http://upload-images.jianshu.io/upload_images/1785959-183d1092bebf88a0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

## 12.6.2简单支付通道示例

要说明状态通道，我们必须从一个非常简单的例子开始。 我们展示一个单向通道，意味着价值只在一个方向流动。 我们还将从天真的假设开始，没有人试图欺骗，让一切保持简单。 一旦我们解释了基本的通道概念，我们就会看见，什么使得它是无信任的，以便任何一方都不能欺骗，即使他们尝试过。对于这个例子，我们假设两个参与者：Emma和Fabian。 Fabian提供视频流服务，后者是消费者，使用微支付通道缴费。 Fabian每秒视频收费0.01毫比（0.00001 BTC），相当于每小时36小时（0.036 BTC）的视频。 Emma是从Fabian购买流媒体视频服务的用户。下图12-5显示Emma使用付款渠道从Fabian购买视频流服务。

![](http://upload-images.jianshu.io/upload_images/1785959-6d796922f33334c1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

在这个例子中，Fabian和Emma正在使用专门的处理支付通道和视频流的软件。 Emma打开软件的浏览器，Fabian管理着服务器。该软件包括基本的比特币钱包功能，可以创建和签署比特币交易。概念和术语“支付通道”都完全对于用户是不可见的。他们看到的是随着时间流失的视频。

为了设置支付通道，Emma和Fabian建立了一个2-2的多重签名地址，每个地址都有一个密钥。从Emma的角度来看，她的浏览器中的软件提供了一个带有P2SH地址的二维码（以“3”开头），并要求她提交最多1小时视频的“存款”。该地址用于Emma付款。支付给多重地址的Emma交易用作支付通道的资金或锚点交易。

就这个例子而言，我们假设Emma支付了36个millibits（0.036 BTC）到通道中。这将允许Emma消费长达1小时的流媒体视频。这种情况下的资金交易设定了可以在这个通道上发送的最大数量，设置了通道容量。

资金交易从Emma的钱包中消耗一个或多个输入。它创建一个输出，其价值为36millibits，支付给Emma和Fabian之间联合控制的多重签名2-2地址。它也可能有额外的作为找零回到Emma的钱包。

一旦资金交易得到确认，Emma可以开始观看视频。Emma的软件创建并签署承诺交易，将渠道余额变更为0.01millibits至Fabian的地址，并退回给Emma的35.99millibits。Emma签署的交易消耗了由资金交易创造的36millibits输出，并创建了两个输出：一个用于退款，另一个用于Fabian的付款。交易只是部分签署 - 它需要两个签名（2 - 2），但只有Emma的签名。当Fabian的服务器接收到此交易时，它会添加第二个签名（用于2-2输入），并将其返回给Emma以及1秒的视频。现在双方都有完全签署的承诺交易，谁都可以兑换，代表通道的正确最新余额。双方都不会将此交易广播到网络。

在下一轮，Emma的软件创建并签署另一个承诺交易（承诺＃2），从资金交易中消耗相同的2-3输出。第二承诺交易分配一个0.2millibits的一个输出到Fabian的地址，一个输出为35.98millibits，作为找零返回给Emma的地址。这个新交易是两个视频的累计秒数。 Fabian的软件签署并返回第二个承诺交易，再加上视频的另一秒。

这样，Emma的软件继续向Fabian的服务器发送承诺交易，以换取流媒体视频。因为Emma消耗更多的视频秒数，通道的余额逐渐积累起来。假设Emma观看600秒（10分钟）的视频，创建和签署600笔承诺交易。最后的承诺交易（＃600）将有两个输出，将通道的余额分成两半，分别为6millibits属于Fabian和30millibits属于Emma。

最后，Emma点击“停止”停止流媒体视频。 Fabian或Emma现在可以发送最终状态交易以进行结算。最后一笔交易是结算交易，并向Fabian支付所有Emma消费的视频，并向Emma退还剩余的资金交易。图12-6显示了Emma和Fabian之间的通道以及更新通道余额的承诺交易。最后，只有两个交易记录在块上：建立通道的资金交易和两个参与者之间正确分配最终余额的结算交易。

![](http://upload-images.jianshu.io/upload_images/1785959-49ab48839864d40d.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

## 12.6.3制造无需信任的通道

我们刚刚描述的通道工作基本政策，但只有双方合作，没有任何失败或企图欺骗。我们来看看打破这个通道的一些场景，看看需要修复的通道：

一旦资金交易发生，Emma需要Fabian的签名才能获得给自己的找零。如果Fabian消失，Emma的资金将被锁定在2-2中，并彻底损失。如果双方之间签署了至少一个承诺交易，其中一方在此之间断开了这个通道，就会导致资金的流失。

当通道正在运行时，Emma可以采取Fabian已经签署的任何承诺交易，并将一个交付给该链。如果她可以传送承诺交易＃1，只支付1秒的视频，为什么要支付600秒的视频？通道失败是因为Emma可以通过广播先前的承诺来欺骗。

这两个问题都可以用timelocks来解决 - 我们来看看我们如何使用交易级时间锁（nLocktime）。

除非她有保证的找零退款，否则Emma不能冒风险进行2-of-2 签名。为了解决这个问题，Emma同时建立了资金和退款交易。她签署资金交易，但不传送给任何人。Emma只将退款交易传送给Fabian，并获得他的签名。

退款交易作为第一承诺交易，其时间锁构建通道生活的上限。在这种情况下，Emma可以将nLocktime设置为30天或4320个区块到将来。所有后续承诺交易必须具有较短的时间锁，以便在退款交易之前赎回它们。

现在，Emma已经完全签署退款交易，她可以自信地转让签署的资金交易，知道她可以在时间到期后最终赎回退款交易，即使Fabian消失也不会有问题。

在通道生活中双方交换的每一项承诺交易都会被时间锁锁进未来。但是，对于每个承诺，延迟会稍短一点，所以最近的承诺可以在之前的承诺无效之前被赎回。由于nLocktime，任何一方都只有其时间到期后才能成功传播任何承诺交易。如果一切顺利，他们将通过结算交易合理地关闭通道，使得不必传送中间的承诺交易。实质上，承诺交易只在一方断线而另一方单方面关闭通道时才使用。

例如，如果将来承诺交易＃1被时间锁定到4320个块，则将来承诺交易＃2被时间锁定到4319个块。在承诺交易＃1变为有效之前，承诺交易＃600可以有600个块的时长。图12-7显示每个承诺交易设置较短的时间锁，允许在之前的承诺变为有效之前花费

![](http://upload-images.jianshu.io/upload_images/1785959-afb8f99e2db2c50a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

每个后续承诺交易必须具有较短的时间锁，以便可以在其前任之前和退款交易之前进行广播。以前广播承诺的能力确保了能够花费资金输出，并排除任何其他承诺交易通过支出来赎回。比特币区块链提供的担保，防止双重支出和执行时间锁定，有效地允许每个承诺交易使其前任无效。

状态通道使用时间锁来在整个时间维度执行智能合同。在这个例子中，我们看到时间维度如何保证最近的承诺交易在任何早先的承诺之前变得有效。因此，最近的承诺交易可以传输，消费输入和使先前的承诺交易无效。绝对时间锁定的智能合同的执行可以防止其中一方的欺骗。此实现只需要绝对的交易级时间锁（nLocktime）。接下来，我们将看到如何使用脚本级时间锁定，CHECKLOCKTIMEVERIFY和CHECKSEQUENCEVERIFY来构建更灵活，有用和复杂的状态通道。

第一种形式的单向支付通道在2015年由阿根廷开发商团队演示为原型视频流应用。你仍然可以在streamsium.io看到它。

时间锁并不是使先前的承诺交易无效的唯一方法。在接下来的章节中，我们将看到如何使用吊销密钥来实现相同的结果。时间是有效的，但它们有两个明显的缺点。通道在通道首次打开时建立最大时间锁，限制通道的使用寿命。更糟糕的是，他们迫使通道实施在允许长期通道，并迫使其中一位参与者在提前关闭的情况下等待很长时间的退款之间取得平衡。例如，如果允许频道保持开放30天，通过将退款时间设置为30天，如果其中一方立即消失，则另一方必须等待30天才能退款。终点越远，退款越远。

第二个问题是，由于每个后续的承诺交易必须减少时间锁定，所以在双方之间可以交换的承诺交易数量有明确的限制。例如，一个30天的通道，在未来设置了4320个块的时间段，只能容纳4320个中间承诺交易，然后才能关闭。将时间锁定承诺交易间隔设置为1个块存在危险。通过将承诺交易之间的时间锁设置为1个区块，开发商必须保持警惕，保持在线和观看的通道参与者创造了非常高的负担，并随时准备传送正确的承诺交易。

现在我们了解如何使用时间锁来使先前的承诺无效，我们可以看到合作关闭通道和通过广播承诺交易单方面关闭通道之间的区别。所有承诺交易都是时间锁定的，因此广播承诺交易将一直到等待时间到期。但是，如果双方同意最后的余额是什么，并且知道他们都承担最终实现余额的承诺交易，那么他们可以构建一个没有时间锁代替相同余额的结算交易。在合作关系中，任一方都采取最近的承诺交易，并建立一个完全相同的交易结算，例外就是它省略了时间锁定。双方都可以签署这笔结算交易，知道无法作弊，得到更多的余额。通过合作签署和转让结算交易，可以立即关闭通道并兑换余额。最恶劣的案件之一，当事人之一可以是卑鄙小人，拒绝合作，强迫另一方单方面关闭最近的承诺交易。但是如果他们这样做，他们也必须等待他们的资金。

## 12.6.4不对称可撤销承诺

处理先前承诺状态的更好方法是明确撤销它们。但是，这不容易实现。比特币的一个关键特征是，一旦交易有效，它一直有效，不会过期。取消交易的唯一方法是在挖矿前用另一笔交易双重支付这个输入。这就是为什么我们在上述简单支付通道示例中使用时间锁定，以确保在旧承诺有效之前可以花费更多的承诺。然而，顺序承诺在时间上造成了许多限制，使得支付通道难以使用。

即使交易无法取消，也可以构造成为不需要的方式。我们这样做是通过给予每一方一个撤销钥匙，如果他们试图欺骗，可以用来进行惩罚。撤销先前承诺交易的这种机制首先被提出作为闪电网络的一部分。

为了解释撤销钥匙，我们将在由Hitesh和Irene经营的两个交易所之间构建一个更加复杂的支付通道。 Hitesh和Irene分别在印度和美国进行比特币交易。 Hitesh的印度交易所的客户经常向Irene的美国交易所的客户发送付款，反之亦然。目前，这些交易发生在比特币链上，但这意味着支付手续费用并等待几个块进行确认。在交易所之间设置支付通道将大大降低成本并加快交易流程。

Hitesh和Irene通过合作建立资金交易启动通道，每笔资金通道使用5个比特币。初始余额为Hitesh的5比特币和Irene的5比特币。资金交易将通道状态锁定在2-of-2 multisig中，就像在简单通道的例子中一样。

资金交易可能有一个或多个来自Hitesh的投入（加起来5个比特币或更多），以及Irene的一个或多个输入（加起来5个比特币或更多）。投入必须略微超过通道容量才能支付交易费用。该交易有一个输出将总共10个比特币锁定到由Hitesh和Irene控制的2-of-2多重地址。如果资金交易的投入超过其预期的通道贡献，资金交易也可能有一个或多个输出将找零返回给Hitesh和Irene。这是由双方提供和签署的投入的单一交易。它必须在合作完成之前由各方签署，然后再传送。

现在，Hitesh和Irene创造了两个不对称的承诺交易，而不是双方签署单一承诺交易。

Hitesh有两个产出的承诺交易。第一个输出支付Irene是欠她的5比特币。第二个输出支付Hitesh是欠他的5比特币，但条件是只有在1000个区块的时间锁之后。交易输出如下所示：Input: 2-of-2 funding output, signed by Irene

Output 0&lt;5 bitcoin&gt;:

```
<
Irene's Public Key
>
 CHECKSIG
```

Output 1:

```
<
1000 blocks
>

CHECKSEQUENCEVERIFY
DROP

<
Hitesh's Public Key
>
 CHECKSIG
```

Irene有不同的承诺交易有两个产出。 第一个输出支付Hitesh欠他的5比特币。 第二个输出支付Irene，欠她的5比特币，但同样只有经过1000个区块的时间段。 Irene持有的承诺交易（由Hitesh签署）看起来像这样：Input: 2-of-2 funding output, signed by Hitesh

Output 0&lt;5 bitcoin&gt;:

```
<
Hitesh's Public Key
>
 CHECKSIG
```

Output 1:

```
<
1000 blocks
>

CHECKSEQUENCEVERIFY
DROP

<
Irene's Public Key
>
 CHECKSIG
```

这样，每一方都有承诺交易，花费2 - 2的资金输出。 该输入由另一方签署才有效。 在任何时候，持有交易的一方也可以签字（完成2到2）并进行广播。 然而，如果他们广播承诺交易，就需要立即支付对方，而他们自己必须等待短时间锁到期。 当我们在选择单方面广播承诺交易时，如果通过拖延赎回其中一项输出，会将各方置于轻微的不利地位。 但是单靠时间延迟还不足以鼓励公平的行为。下图12-8显示两个不对称承诺交易，其中承诺持有人的延迟支付![](http://upload-images.jianshu.io/upload_images/1785959-4aa731f0cfff3add.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)现在我们介绍这个方案的最后一个要素：一个撤销钥匙，允许一个对方通过占用通道的所有余额来惩罚一个骗子。每个承诺交易都有一个“延迟”的输出。 该输出的兑换脚本允许一方在1000个块之后兑换它，或者另一方如果具有插销键，也可兑换它。 所以当Hitesh为Irene签署承诺交易时，他将在1000块之后把第二个可输出支付给自己，或者提交撤销钥匙的人。 Hitesh构建了这个交易，并创建了一个他保密的撤销密钥。 当他准备转移到新的通道状态，并希望撤销这一承诺时，他只会向Irene透露。 第二个输出脚本如下所示：Output 0&lt;5 bitcoin&gt;:

```
<
Irene's Public Key
>
 CHECKSIG
```

Output 1&lt;5 bitcoin&gt;:IF

```
# Revocation penalty output

<
Revocation Public Key
>
```

ELSE

```
<
1000 blocks
>

CHECKSEQUENCEVERIFY
DROP

<
Hitesh's Public Key
>
```

ENDIFCHECKSIGIrene可以自信地签署这笔交易，因为如果发送，它将立即支付她的欠款。 Hitesh持有交易，但知道如果他在单方通道关闭时发送，他将不得不等待1000个块才能获得报酬。

当通道进入下一个状态时，Hitesh必须在Irene同意签署下一个承诺交易之前撤销此承诺交易。要做到这一点，他所要做的就是将撤销钥匙发送给Irene。一旦Irene拥有这一承诺的撤销关键，她就可以自信地签署下一个承诺。她知道，如果Hitesh试图通过发布先前的承诺作弊，她可以使用撤销密钥来赎回Hitesh的延迟输出。如果Hitesh作弊，Irene会得到BOTH（两方）输出。

撤销协议是双边的，这意味着在每一轮中，随着通道状态的进一步发展，双方交换新的承诺，交换撤销钥匙用于以前的承诺，并签署彼此的承诺交易。当他们接受新的状态时，他们使先前的状态不可能使用，相互给予必要的撤销钥匙来惩罚任何作弊。

我们来看一下它的工作原理。 Irene的客户之一希望向Hitesh的客户发送2比特币。要通过通道传输2比特币，Hitesh和Irene必须推进通道状态以反映新的余额。他们将承诺一个新的状态（状态号2），通道的10个比特币分裂，7个比特币到Hitesh和3个比特币到Irene。为了推进通道的状态，他们将创建反映新通道余额的新承诺交易。

像以前一样，这些承诺交易是不对称的，所以每一方的承诺交易都迫使他们等待赎回。至关重要的是，在签署新的承诺交易之前，他们必须首先交换吊销钥匙以使先前的承诺无效。在这种特殊情况下，Hitesh的利益与通道的真实状态是一致的，因此他没有理由广播先前的状态。然而，对于Irene来说，状态号1留给了她比状态2的更高的余额。当Irene给予Hitesh她以前的承诺交易（状态号1）的撤销钥匙时，她正在有效地撤销她的受益于将通道退回到先前的能力，因为撤销密钥，Hitesh可以毫不拖延地兑换先前承诺交易的两个输出。意思如果Irene广播先前的状态，Hitesh可以行使其占有所有输出的权利。

重要的是，撤销不会自动发生。虽然Hitesh有能力惩罚Irene作弊，但他必须勤勉地观察这个区块链的作弊签署行为。如果他看到先前的承诺交易广播，他有1000个区块实践采取行动，并使用撤销密钥来阻止Irene的欺骗和惩罚她，占有所有余额也就是10比特币。

相对时间锁（CSV）的不对称可撤销承诺是实现支付通道和这项技术非常重要的创新的更好方法。通过这种结构，通道可以无限期地保持开放，并且可以拥有数十亿的中间承诺交易。在闪电网络的原型实现中，承诺状态由48位索引识别，允许在任何单个通道中超过281兆（2.8×10^14）个状态转换！

## 12.6.5哈希时间锁合约（Hash Time Lock Contracts，HTLC）

支付通道可以通过特殊类型的智能合同进一步扩展，允许参与者将资金用于可赎回的具有到期时间的秘密（secret）。 此功能称为哈希时间锁定合约或HTLC，并用于双向和可路由的支付通道。

首先解释HTLC的“哈希”部分。 要创建一个HTLC，预期的收款人将首先创建一个秘密（secret）R。他们然后计算这个R的哈希H：H = Hash\(R\)这产生可以包含在输出的锁定脚本中的哈希H。 谁知道秘密可以用它来赎回输出。 秘密R也被称为哈希函数的前图像。 前图像只是用作哈希函数输入的数据。

HTLC的第二部分是“时间锁”组件。 如果秘密没有透露，HTLC的付款人可以在一段时间后得到“退款”。 这是通过使用CHECKLOCKTIMEVERIFY的绝对时间锁来实现的。实现HTLC的脚本可能如下所示：IF

```
# Payment if you have the secret R
HASH160 
<
H
>
 EQUALVERIFY
```

ELSE

```
# Refund after timeout.

<
locktime
>
 CHECKLOCKTIMEVERIFY DROP

<
Payee Pubic Key
>
 CHECKSIG
```

ENDIF知道秘密R的人，当哈希等于H时，可以通过行使IF语句的第一个子句来兑换该输出。如果秘密不透露，HTLC声称，在一定数量的块之后，收款人可以使用IF语句中的第二个子句申请退款。

这是HTLC的基本实现。 任何拥有秘密R的人都可以兑换这种类型的HTLC。HTLC可以采用许多不同的形式，对脚本有轻微的变化。 例如，在第一个子句中添加一个CHECKSIG运算符和一个公钥来限制将哈希值兑换成一个指定的收件人，这个人必须知道秘密R.

# 12.7可路由的支付通道（闪电网络）

闪电网络是一种端到端连接的双向支付通道的可路由网络。这样的网络可以允许任何参与者将支付从一个通道路由到另一个通道，而不需要信任任何中间人。闪电网络由Joseph Poon和Thadeus Dryja于2015年2月首次描述，其基础是许多其他人提出和阐述的支付通道概念。

“闪电网络”是指路由支付通道网络的具体设计，现已由至少五个不同的开源团队实施。独立实施是由“闪电技术基础”（BOLT）论文中描述的一组互操作性标准进行协作。

闪电网络的原型实施已经由几个团队发布。现在，这些实现只能在testnet上运行，因为它们使用segwit，还没有在主比特币块（mainnet）上激活。

闪电网络是实现可路由支付通道的一种可能方式。还有其他几种旨在实现类似目标的设计，如Teechan和Tumblebit。

## 12.7.1闪电网络示例

让我们看看这是如何工作的。在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都有2个比特币资金，每个通道的总容量为4个比特币。

下图12-9显示在闪电网络中五名参与者，通过双向支付通道连接，可从Alice到Eric的付款

![](http://upload-images.jianshu.io/upload_images/1785959-edf90a5ceff5a36e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)Alice想要支付Eric1个比特币。 不过，Alice并未通过支付通道连接到Eric。 创建支付通道需要资金交易，而这笔交易必须首先提交给比特币区块链。 Alice不想打开一个新的支付通道并支出更多的手续费。 有没有办法间接支付Eric？下图12-10显示了通过在连接各方参与者的支付通道上通过一系列HTLC承诺将付款从Alice路由到Eric的逐步过程。

![](http://upload-images.jianshu.io/upload_images/1785959-4a7600f41ee8499a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1240)

Alice正在运行闪电网络（LN）节点，该节点正在跟踪其向Bob的付费通道，并且能够发现支付通道之间的路由。Alice的LN节点还具有通过互联网连接到Eric的LN节点的能力。 Eric的LN节点使用随机数生成器创建一个秘密R。Eric的节点没有向任何人泄漏这个秘密。相反，Eric的节点计算秘密R的哈希H，并将此哈希发送到Alice的节点（请参阅图12-10步骤1）。

现在Alice的LN节点构建了Alice的LN节点和Eric的LN节点之间的路由。所使用的路由算法将在后面进行更详细的检查，但现在我们假设Alice节点可以找到一个有效的路由。

然后，Alice的节点构造一个HTLC，支付到哈希H，具有10个区块时间的退款超时（当前块+10），数量为1.003比特币（参见图12-10的步骤2）。额外的0.003将用于补偿中间节点参与此支付路由。Alice将此HTLC提供给Bob，从Bob的通道余额中扣除1.003比特币，并将其提交给HTLC。 HTLC具有以下含义：“如果Bob知道秘密，Alice将其通道余额的1.003提交给Bob，或者如果经过10个区块生产时间，则退还给Alice的余额”。 Alice和Bob之间的通道余额现在由承诺交易表示，其中有三个输出：Bob的2比特币余额，Alice的0.997比特币余额，Alice的HTLC中的1.003比特币。Alice的余额减少了向HTLC承诺的金额。

Bob现在有一个承诺，如果他能够在接下来的10个区块生产时间内获得秘密R，他可以要求Alice锁定1.003。通过这一承诺，Bob的节点在Carol的支付通道上构建了一个HTLC。Bob的HTLC提交1.002比特币哈H 共9个区块时间，Carol可以兑换，如果她有秘密R（参见图12-10步骤3）。Bob知道，如果Carol可以要求他的HTLC，她必须生产R，如果Bob有9个区块的R，他可以用它来向他索要Alice的HTLC。他还使用0.001比特币提供9个区块的通道余额。如果Carol无法申请他的HTLC，并且他无法申请Alice的HTLC，那么一切都将恢复到以前的通道余额，没有人会亏损。 Bob和Carol之间的通道余额现在是：2到Carol，0.998给Bob，1.002由Bob提交给HTLC。

Carol现在有一个承诺，如果她在接下来的9个区块时间内获得R，她可以要求Bob锁定1.002比特币。现在她可以在她的通道上与Diana达成HTLC承诺。她提交了一个1.001比特币的HTLC哈希H，共计8个区块时间，如果Diana有秘密R ，她就可以兑换（参见图12-10步骤4）。从Carol的角度来看，如果能够实现，她就可以获得的0.001比特币，否则也没有失去任何东西。她提交给Diana的HTLC，只有在R被泄漏的情况下才可行，那时候她可以从Bob那里索取HTLC。Carol和Diana之间的通道余额现在是：2到Diana，0.999到Carol，1.001由Carol向HTLC承诺。

最后，Diana可以提供给Eric一个HTLC，承诺1比特币，7个区块时间，哈希H（参见图12-10的步骤5）。Diana与Eric之间的通道余额现在是：2到Eric，1到Diana，1由Diana承诺给HTLC。

然而，在这条路上，Eric拥有秘密R，他可以要求Diana提供的HTLC。他将R发送给Diana，并要求将1个比特币，添加到他的通道余额（参见图12-10的步骤6）。通道平衡现在是：1到Diana，3到Eric。

现在，Diana有秘密R，因此，她现在可以从Carol声称HTLC。Diana将R发送给Carol，并将1.001比特币添加到其通道余额（参见图12-10的步骤7。现在Carol与Diana之间的通道余额是：0.999到Carol，3.001到Diana。Diana已经“赚了”0.001参与这个付款路线。

通过路由回传，秘密R允许每个参与者要求未完成的HTLC。Carol从Bob要求1.002个比特币，将他们通道余额设为：0.998到Bob，3.002到Carol（参见闪电网络步骤8）。最后，Bob从Alice中声称HTLC（参见闪电网络步骤9）。他们的频道余额更新为：0.997给Alice，3.003给Bob。

Alice已经支付了Eric 1比特币，并没有向Eric打开通道。付款路线中的中间方不得互相信任。对于他们的资金在通道中的短期承诺，他们可以赚取一小笔费用，如果通道关闭或路由付款失败，唯一的风险是时间很短的退款。

## 12.7.2闪电网络传输和路由

LN节点之间的所有通信都是点对点加密的。 另外，节点有一个长期的公钥，[它们用作标识符并且彼此认证](http://bit.ly/2r5TACm)。

每当节点希望向另一个节点发送支付时，它必须首先通过连接具有足够容量的支付通道来构建通过网络的路径。节点广告路由信息，包括他们已经打开什么通道，每个通道拥有多少容量，以及他们收取多少路由支付费用。路由信息可以以各种方式共享，并且随着闪电网络技术的进步，不同的路由协议可能会出现。一些闪电网络实施使用IRC协议作为节点宣布路由信息的一种方便的机制。路由发现的另一种实现方式是使用P2P模型，其中节点将通道公告传播给对等体，在“洪泛”模型中，类似于比特币如何传播交易。未来的计划包括一个名为[Flare](http://bit.ly/2r5TACm)的建议，它是一种具有本地节点“邻居”和较长距离的信标节点的混合路由模型。

在我们前面的例子中，Alice的节点使用这些路由发现机制之一来查找将她的节点连接到Eric的节点的一个或多个路径。一旦Alice的节点构建了路径，她将通过网络初始化该路径，传播一系列加密和嵌套的指令来连接每个相邻的支付通道。

重要的是，这个路径只有Alice的节点才知道。付款路线上的所有其他参与者只能看到相邻的节点。从Carol的角度来看，这看起来像是从Bob到Diana的付款。 Carol不知道Bob实际上是从Alice汇款。她也不知道Diana将会向Eric转账。

这是闪电网络的一个重要特征，因为它确保了付款的隐私，并且使得很难应用监视，审查或黑名单。但是，Alice如何建立这种付款途径，而不向中间节点透露任何内容？

闪电网络实现了一种基于称为Sphinx的方案的洋葱路由协议。该路由协议确保支付发送者可以通过闪电网络构建和通信路径，使得：中间节点可以验证和解密其部分路由信息，并找到下一跳。除了上一跳和下一跳，他们不能了解作为路径一部分的任何其他节点。他们无法识别支付路径的长度，或者他们自己在该路径中的位置。路径的每个部分被加密，使得网络级攻击者不能将来自路径的不同部分的分组彼此关联。

不同于Tor（互联网上的洋葱路由匿名协议），没有可以被监视的“退出节点”。付款不需要传输到比特币区块链，节点只是更新通道余额。

使用这种洋葱路由协议，Alice将路径的每个元素包裹在一层加密中，从结束开始并向后工作。她用Eric的公钥加密了Eric的消息。该消息包裹在加密到Diana的消息中，将Eric标识为下一个收件人。给Diana的消息包裹在加密到Carol的公钥的消息中，并将Diana识别为下一个收件人。对Carol的消息被加密为Bob的密钥。因此，Alice已经构建了这个加密的多层“洋葱”的消息。她发送给Bob，他只能解密和解开外层。在里面，Bob发现一封给Carol的消息，他可以转发给Carol，但不能破译自己。按照路径，消息被转发，解密，转发等，一直到Eric。每个参与者只知道每一跳中的前一个和下一个节点。

路径的每个元素包含必须扩展到下一跳的HTLC信息，要发送的数量，要包括的费用以及HTLC的CLTV锁定时间（以块为单位）到期。随着路由信息的传播，节点将HTLC承诺转发到下一跳。

在这一点上，您可能会想知道节点如何不知道路径的长度及其在该路径中的位置。毕竟，他们收到一个消息，并将其转发到下一跳。它不会将路径缩短，或者允许他们推断出路径大小和位置？为了防止这种情况，路径总是固定在20跳，并用随机数据填充。每个节点都会看到下一跳和一个固定长度的加密消息转发。只有最终的收件人看到没有下一跳。对于其他人来说，似乎总共有20多跳。

## 12.7.3闪电网络优势

闪电网络是第二层路由技术。它可以应用于支持一些基本功能的任何区块链，如多重签名交易，时间锁定和基本的智能合同。如果闪电网络分层在比特币网络之上，则比特币网络可以大大提高容量，隐私性，粒度和速度，而不会牺牲无中介机构的无信任操作原则：隐私闪电网络付款比比特币区块链的付款更私有，因为它们不是公开的。虽然路由中的参与者可以看到在其通道上传播的付款，但他们不知道发件人或收件人。可替代性闪电网络使得在比特币上应用监视和黑名单变得更加困难，从而增加了货币的可替代性。速度使用闪电网络的比特币交易将以毫秒为单位，而不是分钟，因为HTLC被清除，而不会将交易提交给块。粒度闪电网络可以使支付至少与比特币“灰尘”限制一样小，甚至更小。一些建议允许次级增量。容量闪电网络将比特币系统的容量提高了几个数量级。每秒可以通过闪电网络路由的每秒付费数量没有实际的上限，因为它仅取决于每个节点的容量和速度。无关操作闪电网络在不相互信任的情况下使用作为对等体的节点之间的比特币交易。因此，闪电网络保留了比特币系统的原理，同时显著扩大了其操作参数。

当然，如前所述，闪电网络协议不是实现路由支付通道的唯一方法。其他提出的系统包括Tumblebit和Teechan。然而，在这个时候，闪电网络已经部署在testnet上了。几个不同的团队已经开发了LN的竞争实施，并且正在努力实现一个通用的互操作性标准（称为BOLT）。闪电网络可能是第一个部署在生产中的路由支付通道网络。

# 12.8结论

我们仅研究了可以使用比特币区块链链作为信任平台构建的新兴应用程序。这些应用程序将比特币的范围扩大到超出付款和超越金融工具的范围，以涵盖信任至关重要的许多其他应用程序。通过分散信任基础，比特币区块链是一个平台，将在各种行业中产生许多革命性的应用。

