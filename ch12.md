# 第12章 区块链应用
现在，让我们把比特币作为一个*应用平台application platform*，进一步加深理解。现在很多人使用“区块链”这个词来表示任何共享了比特币设计原则的应用平台。 该术语经常被滥用，并被应用于许多不能提供比特币区块链主要功能的事情。

在本章中，我们将介绍比特币区块链作为应用平台所提供的功能。 我们将考虑应用程序的开发*要素primitives*，即组成任何区块链应用程序的开发模块。我们将研究使用这些要素的几个重要应用程序，例如染色币，支付（状态）渠道和路由支付通道（闪电网络）。

## 12.1 介绍

比特币系统被设计为一个去中心化的货币及支付系统。然而，它的大部分功能都是从底层的概念派生出来的，这些概念被更广泛用于许多应用程序。比特币不是由帐户，用户，余额和付款等组件构建的。相反的，就像我们在[【第6章交易】](https://github.com/tianmingyun/MasterBitcoin2CN/blob/master/ch06.md)中看到的，它使用的是具有低级加密函数的交易脚本语言。就像账户，余额和付款这些更高级的概念可以从基本要素衍生出来一样，许多其他复杂的应用也是如此。 因此，比特币区块链可以成为一个向诸如智能合同等应用程序提供信任服务的应用平台，远远超出了作为数字货币和支付的最初目的。

## 12.2 开发模块（要素）

当比特币系统长期稳定运行时，它就提供了一定的保证，可以作为开发模块来创建应用程序。 这些包括：

**杜绝双重支付** 

比特币去中心化共识算法的最根本保证是确保同一UTXO不会被花费两次。

**不可篡改性** 

一旦交易被记录在区块中，并且随后的区块中添加了足够的工作量，该交易数据就变得不可篡改。不可篡改性是由能源进行保证的，因为重写区块链需要花费能源才能产生工作量证明。随着在包含交易的区块之后被提交的工作量增加，所需的能源以及由此带来的不篡改的程度也在增加。

**中立** 

去中心化的比特币网络传播有效的交易，而不管这些交易的来源或内容如何。这意味着任何人都可以支付足够的费用来创建有效的交易，并相信别人会随时传输该交易并将其包含在区块链中。

**安全时间戳** 

共识规则拒绝任何时间戳距离现在太远的区块，包括过去或将来。这可以确保区块上的时间戳是可信的。区块上的时间戳意味着一种保证，保证交易包含的全部输入之前都是未花费的。

**授权** 

在去中心化网络中验证过的数字签名可提供授权保证。未经脚本中隐含的私钥的持有人的授权，包含数字签名要求的该脚本就不能被执行。

**审计能力** 

所有交易都是公开的，可以被审计。所有的交易和交易所属的区块都可以在一个完整的链中链接回到创世区块。

**会计** 

在任何交易中（创币交易除外），输入的金额等于输出的金额加上交易费。在交易中不可能创建或销毁比特币价值。输出不能超过输入。

**永不过期** 

有效的交易永远不会过期。如果今天有效，它在将来仍然有效，只要那个输入未被花费，共识规则没有改变。

**公正性** 

使用SIGHASH_ALL签名的比特币交易或由另外的SIGHASH类型签名的交易的部分，不能在未使签名无效的情况下被修改，如果修改将导致交易本身无效。

**交易原子性** 

比特币交易是原子性的。 它们要么是有效的并且经过确认的（挖矿），要么不是。不存在挖出不完整的交易，交易也不存在过渡状态。在任何时间点，交易要么被挖出，要么没有被挖出。

**离散（不可分割）价值单位** 

交易输出是离散和不可分割的价值单位。它们要么整体被花费，要么未被花费，不能被分割或者部分被花费。

**法定人数控制** 

脚本中的多重签名约束强制执行多重签名方案中预定义的法定人数授权。M/N要求由共识规则执行。

**时间锁/老化** 

任何包含相对或绝对时间锁的脚本子句只能在其期限超过指定时间后执行。

**复制** 

区块链的去中心化存储确保了在交易在被挖出之后，经过充分的确认，它被复制到整个网络上，就变成永久性的，并且能够抵御断电，数据丢失等的影响。

**伪造保护** 

每笔交易只能花费现有的经过验证的输出。不可能创建或伪造价值。

**一致性** 

在没有矿工分区的情况下，记录在区块链中的区块将根据记录深度进行重组，或者其不一致的可能性将以指数递减。一旦被记录在深层，如果想要改变，所需的计算和能量将大到几无可能。

**记录外部状态** 

每个交易可以通过OP_RETURN提交一个值，表示外部状态机中的状态转换。

**可预测发行量** 

总计不到2100万个比特币将会以可以预测的速度发行。

上述开发模块的列表并不完整，还会有新功能将被介绍添加到比特币中。

## 12.3 源于开发模块的应用

由比特币提供的开发模块是可信平台的组成部分，可用于构成各种应用程序。以下是今天在用的应用程序的一些示例及其使用的开发模块：

**存在证明（数字公证）Proof-of-Existence（Digital Notary）** 

不可篡改性+时间戳+永久性。数字指纹可以通过一个交易提交给区块链，证明在记录时存在一个文档（时间戳）。数字指纹不能在事后修改（不可篡改性），证据将被永久保存（永久性）。

**众筹（Lighthouse项目）Kickstarter（Lighthouse）** 

一致性+原子性+完整性。如果您签署了一个众筹交易的输入和输出（完整性），其他人可以为资金众筹做出贡献，但在目标（就是输出值）获得资金（一致性）之前，不能使用（原子性）。

**支付通道Payment Channels** 

法定人数控制+时间锁+杜绝双重支付+永不过期+耐审查+授权。带有时间锁（Timelock）的2/2（法定人数）多重签名被作为支付通道的“结算”交易时，可以被持有（永不过期）或者在任何时间由任何一方（授权）的情况下（耐审查）进行花费。然后双方可以创建更短的时间锁（Timelock）的承诺交易，双重支付（杜绝之前的双重支付）该结算交易。

## 12.4 染色币

我们将讨论的第一个区块链应用是*染色币colored coins*。

染色币是指利用比特币交易来记录除比特币之外的外部资产的创建，所有权和转让的这类技术。 所谓“外部资产”是指这些资产不直接存储在比特币区块上，而不是指比特币本身，因为比特币是本身就是这个区块链的固有资产。

染色币用于跟踪第三方持有的数字资产和实物资产，并通过染色币所有权证书来进行交易。数字资产染色币可以代表无形资产，如股票证书，许可证，虚拟财产（游戏装备）或大多数任何形式的许可知识产权（商标，版权等）。有形资产染色币可以代表商品（黄金，白银，石油），土地所有权，汽车，船只，飞机等所有权。

该术语源于“着色”或标记比特币的名义金额的理念，例如，1聪，用来表示比特币价值本身以外的东西。打个比方，我们给一美元的钞票加盖一条信息说：“这是ACME的股票证书”，或者“这张钞票可以兑换1盎司的银”，然后使用这个1美元钞票作为这个其他资产权益证明来进行交易。染色币的第一次实施，名为*基于增强填充订单的着色”Enhanced Padded-Order-Based Coloring*或*EPOBC*，将外部资产标记于1聪输出上。这样，因为每个资产作为1聪的属性（颜色）被添加了，它就成了一个真正的“染色币”。

染色币的最新实施使用OP_RETURN脚本操作码将交易中的元数据，与将元数据与特定资产相关联的外部数据存储结合在一起。

今天染色币的两个最突出的实现是 Open Assets和Colu的染色币。这两个系统使用不同的方法来染色，并不兼容。在一个系统中创建的染色币无法在其他系统中看到或使用。

### 12.4.1 使用染色币

染色币是在特殊的钱包中创建、传输和查看的，这些钱包可以解释附在比特币交易上的彩色硬币协议元数据。必须特别注意避免在常规的比特币钱包中使用染色币相关的密钥，因为常规钱包可能会破坏元数据。同样地，染色币也不应该被发送到由常规钱包管理的地址，而只能发送到由染色币能够识别的钱包管理的地址。Colu和Open Assets这两个系统都使用特殊的染色币地址来减轻这种风险，并确保染色币不会发送到不能识别的钱包。

染色币对大多数通用的区块链浏览器也是不可见的。相反，必须使用染色币浏览器来解释染色币交易的元数据。

Open Assets兼容的钱包应用程序和区块链浏览器可以在[coinprism](https://www.coinprism.info/)查找。

Colu染色币兼容的钱包应用程序和区块链浏览器可以在[Blockchain Explorer](http://coloredcoins.org/explorer/)中找到。

Copay钱包插件可以在[Colored Coins Copay Addon](http://coloredcoins.org/colored-coins-copay-addon/)中找到。

### 12.4.2 发行染色币

每个染色币的实现都通过不同的方法创造染色币，但它们都提供类似的功能。创造染色币资产的过程称为*发行issuance*。初始交易，名为发行交易issuance transaction将资产登记在比特币区块链上，并创建用于引用资产的*资产IDasset ID*。一旦发行，资产可以使用*转账交易transfer transactions*在地址之间传递。

作为染色币发行的资产可以有多种属性。它们可以是*可分割的divisible*或*不可分割的indivisible*，这意味着转账中的资产量可以是整数（比如5）或具有十进制细分（比如4.321）。资产也可以*固定发行fixed issuance*，意思是一定数量的资产只可以发行一次，或者可以被*再次发行reissued*，后者意味着原始发行人在初始发行后可以重新发行新资产单位。

最后，一些染色币启用*分红dividends*，允许将比特币付款按其所有权比例分配给染色币资产的所有者。

### 12.4.3 染色币交易

给染色币交易提供意义的元数据通常使用OP_RETURN操作码存储在其中一个输出中。不同染色币协议对OP_RETURN数据的内容使用不同的编码。包含OP_RETURN的输出称为*标记输出marker output*。

在染色币协议中，输出的顺序和标记输出的位置可能具有特殊含义。例如，在Open Assets中，标记输出之前的任何输出都代表资产发行。标记输出后的任何输出表示资产转账。标记输出通过引用其他输出在交易中的顺序为它们分配特定的值和颜色。

作为对比，在Colored Coins (Colu)中，标记输出对决定元数据如何解释的操作码进行编码。操作码0x01至0x0F表示发行交易。发行操作码通常后面是资产ID或可用于从外部来源（例如bittorrent）取得资产信息的其他标识符。操作码0x10到0x1F表示转账交易。通过引用特定数量的资产的索引，将其从输入传输到输出。因此，输入和输出的顺序对脚本的解释很重要。

如果元数据太长而不能放入OP_RETURN，则染色币协议可能会使用其他“技巧”在交易中存储元数据。示例包括将元数据放在兑换脚本中，紧接着OP_DROP操作码，以确保脚本忽略元数据。使用的另一种机制是1/N多重签名脚本，其中只有第一个公钥是可以花费输出的真实公钥，随后的“密钥”则用被编码的元数据替代。

为了正确解释染色币交易中的元数据，您必须使用兼容的钱包或区块资源浏览器。否则，该交易会看起来像一个具有OP_RETURN输出的“正常”比特币交易。

例如，我使用染色币创建并发行了MasterBTC资产。 “MasterBTC”代表了可以获取本书免费副本的兑换券。这些兑换券可以使用染色币兼容的钱包进行转让，交易和兑换。

对于这个特定的例子，我使用了[https://coinprism.info](https://coinprism.info/)的钱包和浏览器，它使用了Open Assets染色币协议。

下图12-1显示使用Coinprism区块浏览器的发行交易：

https://www.coinprism.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec

![图12-1. 在coinprism.info上查看的发行交易](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1201.png)

图12-1  在coinprism.info上查看的发行交易

正如你所看到的那样，coinprism显示了发行的20个“精通比特币的免费副本”，简称为MasterBTC的资产，发给了一个特殊的染色币地址：

akTnsDt5uzpioRST76VFRQM8q8sBFnQiwcx

>**警告**  发送到该地址的任何资金或染色币将永远丢失。不要发送到这个示例地址！

发行交易的交易ID是“正常”比特币交易ID。下图12-2显示同一笔交易（和12.1同一笔）在对染色币不能解码的区块浏览器中的样子。我们将使用blockchain.info：

https://blockchain.info/tx/10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec

![图12-2. 不对染色币进行解码的区块链浏览器中看到的发行交易](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1202.png)

图12-2  对染色币不能解码的区块链浏览器中看到的发行交易

正如你所看到的，blockchain.info不认为这是一个染色币交易。事实上，它以红色字母表示第二个输出“无法解码输出地址”。

如果您在该屏幕上选择“显示脚本和coinbase”，可以看到有关交易的更多详细信息(下图12-3)。

![图12-3. 发行交易的脚本](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1203.png)

图12-3  发行交易的脚本

再次，blockchain.info还是不能理解第二个输出。它以红色字母表示“奇怪”。 但是，我们可以看到，标记输出中的一些元数据是可读的：

```
OP_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559
(decoded) "OA____u=https://cpr.sm/FoykwrH6UY
```

让我们使用bitcoin-cli检索交易：

```
$ bitcoin-cli decoderawtransaction`bitcoin-cli getrawtransaction 10d7c4e022f35288779be6713471151ede967caaa39eecd35296aa36d9c109ec
```

删除其余的交易，第二个输出如下所示：

```
{
    "value": 0.00000000,
    "n": 1,
    "scriptPubKey": "OP\_RETURN 4f41010001141b753d68747470733a2f2f6370722e736d2f466f796b777248365559"
}
```

前缀4F41表示字母“OA”，代表“Open Assets”，并帮助我们确定以下元数据是由Open Assets协议定义的，紧接着的ASCII编码的字符串是指向资产定义的链接：

```
u=https://cpr.sm/FoykwrH6UY
```

如果我们检索此URL，我们将获得JSON编码的资产定义，如下所示：

```
{
  "asset_ids": [
    "AcuRVsoa81hoLHmVTNXrRD8KpTqUXeqwgH"
  ],
  "contract_url": null,
  "name_short": "MasterBTC",
  "name": "Free copy of \"Mastering Bitcoin\"",
  "issuer": "Andreas M. Antonopoulos",
  "description": "This token is redeemable for a free copy of the book \"Mastering Bitcoin\"",
  "description_mime": "text/x-markdown; charset=UTF-8",
  "type": "Other",
  "divisibility": 0,
  "link_to_website": false,
  "icon_url": null,
  "image_url": null,
  "version": "1.0"
}
```

## 12.5 合约币（Counterparty）

合约币是在比特币之上建立的协议层。与“染色币”类似的“合约币协议”提供了创建和交易虚拟资产和代币的能力。此外，合约币提供了去中心化的资产交换。合约币还在实施基于Ethereum虚拟机（EVM）的智能合约。

像染色币协议一样，合约币使用OP_RETURN操作码或1/N多重签名的公钥地址将元数据嵌入到比特币交易中，该地址用于代替公共密钥进行元数据编码。使用这些机制，合约币实现了在比特币交易中编码的协议层。额外的协议层可以由能理解合约币的应用程序来解读，如钱包和区块链浏览器，或使用合约币库（library）构建的任何应用程序。

反过来合约币可以用作给其他应用程序和服务的平台。例如，Tokenly是一个建立在合约币之上的平台，允许内容创作者，艺术家和公司发行表示数字所有权的代币，并可用于租赁，访问，交易或购买内容，产品和服务。利用交易合约币的其他应用包括游戏（Spells of Genesis）和网格计算项目（(Folding Coin）。

更多关于合约币的内容参见[https://counterparty.io](https://counterparty.io/)。开源项目可以在<https://github.com/CounterpartyXCP>中找到。

## 12.6 支付通道和状态通道

*支付通道Payment channels*是在比特币区块链之外，双方交换比特币交易的无信任机制。这些交易，如果在比特币区块链上结算，则是有效的，然而他们却是在链外被持有的，以*期票promissory notes*的形式等待最终批量结算。由于交易尚未结算，因此可以在没有通常的结算延迟的情况下进行交换，从而可以满足极高的交易吞吐量，低（亚毫秒）延迟和精细（satoshi级）粒度。

实际上，*通道channel* 一词是一个比喻。状态通道是区块链外，由双方之间的交换状态代表的虚拟构想。实际上没有“通道”，底层数据传输机制也并不是通道。我们使用通道这个术语来表示链外双方之间的关系和共享状态。

为了进一步解释这个概念，想一想TCP流。从高层协议的角度来看，它是一个横跨互联网连接两个应用程序的“socket”。但是，如果您查看网络流量，TCP流只是IP数据包之上的虚拟通道。TCP流的每个端点通过排序并组装IP数据包以产生字节流的错觉。实际上在背后，所有的数据包都是断开分散的。同理，支付通道只是一系列交易。如果妥善排序和连接，它们会创建可赎回的合约，即使您不信任通道的另一方，也可以信任这些合约。

在本节中，我们将介绍各种形式的支付通道。首先，我们将研究用于构建计量小额支付服务（如流媒体视频）的单行（单向）支付通道的机制。然后，我们将扩大这一机制，引入双向支付通道。最后，我们将看看首先在 *闪电网络Lightning Network* 中提出的，如何在路由网络中端到端地连接双向通道以形成多跳通道。

支付通道是更广泛的*状态通道state channel*概念的一部分，状态通道代表了链外状态的变化，通过最终在区块链上结算得到保障。支付通道是一种状态通道，其中被改变的状态是虚拟货币余额。

### 12.6.1 状态通道基本概念和术语

通过在区块链上锁定共享状态的交易，在交易两方之间建立了一个状态通道。这被称为*注资交易funding transaction*或*锚点交易anchor transaction*。这笔交易必须传送到网络并被挖矿确认，才能建立通道。在支付通道的示例中，锁定的状态即为通道的初始余额（以货币计）。

随后双方交换已签名的交易，这被称为*“承诺交易commitment transactions”*。承诺交易会改变初始状态。这些交易是有效的交易，因为它们*可以*被任何一方提交进行结算，但是在通道关闭之前，每一方都会将其在链下保留。状态更新的创建速度可以与每一方创建、签名并将交易传输给另一方的速度一样快。实际上，这意味着每秒可以交换数千笔交易。

当交换承诺交易时，双方同时废止之前的状态，这样最新的承诺交易总是唯一可以兑换的承诺交易。这样可以防止任何一方在通道中某个先前状态比最新状态更有利于己方的时候通过单方面关闭通道来进行欺骗。我们将在本章的其余部分中研究可用于无效先前状态的各种机制。

最后，通道可以协商关闭，即向区块链提交最后的*结算交易settlement transaction*，或者由任何一方单方面提交最后承诺交易到链上。单方面关闭的选项是必要的，以防万一交易中的一方意外断开连接。结算交易代表通道的最终状态，并在链上进行结算。

在通道的整个生命周期中，只有两个交易需要提交给链上进行挖矿：注资交易和结算交易。在这两个状态之间，双方可以交换任何数量的承诺交易，任何其他人永远不会看到，也不会提交到链上。

下图12-4说明了Bob和Alice之间的支付通道，显示了注资交易，承诺交易和结算交易。

![图12-4. Bob和Alice之间的支付通道，显示了注资，承诺和结算交易](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1204.png)

图12-4 Bob和Alice之间的支付通道，展示了注资交易，承诺交易和结算交易

### 12.6.2 简单支付通道示例

要说明状态通道，我们必须从一个非常简单的例子开始。 我们展示一个单向通道，意味着价值只向着一个方向流动。为了便于解释，我们以一个天真的假设开始，假设没有人要试图欺骗他人。一旦我们解释了基本的通道概念，我们将研究如何使其不可信，以便双方都*不能*作弊，即使他们试图作弊。

对于这个例子，我们假设两个参与者：Emma和Fabian。Fabian提供视频流服务，使用微支付通道按秒计费。Fabian每秒视频收费0.01毫比（millibits）（0.00001 BTC），相当于每小时视频收费36毫比（0.036 BTC）。Emma从Fabian这里购买流媒体视频服务。下图12-5显示Emma使用支付通道从Fabian购买视频流服务。

![图12-5.Emma使用以秒计费的支付通道从Fabian购买视频流服务](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1205.png)

图12-5 Emma使用以秒计费的支付通道从Fabian购买视频流服务

在这个例子中，Fabian和Emma使用专门的软件来处理支付通道和视频流。Emma在浏览器中运行软件，Fabian从服务器端运行软件。这个软件包括基本的比特币钱包功能，可以创建和签署比特币交易。“支付通道”的概念和术语对于用户都是完全不可见的。他们看到的是以秒为单位付费的视频。

为了设置支付通道，Emma和Fabian建立了一个2/2的多重签名地址，双方各持一个密钥。从Emma的角度来看，她的浏览器中的软件提供了一个带有P2SH地址的二维码（以“3”开头），并要求她提交最多1小时视频的“押金”。Emma向该地址支付资金。Emma支付给该多重地址的交易，就是支付通道的注资交易或叫锚点交易。

就这个例子而言，我们假设Emma支付了36个毫比（0.036 BTC）到通道中。这将允许Emma消费长达1小时的流媒体视频。这笔注资交易设定了可以在这个通道上发送的最大数量（数据量），即设置了*通道容量 channel capacity*。

注资交易从Emma的钱包中消耗一个或多个输入以汇集资金。它创建一个价值为36毫比的输出，支付给Emma和Fabian之间共同控制的2/2多重签名地址。它也可能有一个作为找零到Emma的钱包的额外输出。

一旦注资交易得到确认，Emma可以开始观看视频。Emma的软件创建并签署一笔承诺交易，改变通道余额，将0.01毫比归入Fabian的地址，并退回给Emma35.99毫比。Emma签署的交易消耗了由注资交易创造的36毫比输出，并创建了两个输出：一个用于找钱，另一个用于Fabian的付款。交易只是部分被签署了，它需要两个签名（2/ 2），但现在只有Emma的签名。当Fabian的服务器接收到此交易时，它会添加第二个签名（用于2/2输入），并将其与时长1秒的视频一起返回给Emma。现在双方都有谁都可以兑换的完全签署的承诺交易，这个承诺交易代表着通道中的最新正确余额。双方都不会将此交易广播到网络中。

在下一轮，Emma的软件创建并签署另一个承诺交易（2号承诺交易），该交易从资金交易中消耗*相同的*2/2输出。2号承诺交易分配0.2毫比的一个输出到Fabian的地址，还有一个输出为35.98毫比，作为找零返回给Emma的地址。这个新交易支付的是累积两秒的视频内容。Fabian的软件签署并返回第二个承诺交易，再加上另一秒视频。

利用上述的方法，Emma的软件继续向Fabian的服务器发送承诺交易，以换取流媒体视频。因为Emma观看了更多秒数的视频，通道中属于Fabian的钱逐渐累积变多。假设Emma观看600秒（10分钟）的视频，创建和签署600笔承诺交易。最后的承诺交易（600号承诺交易）将有两个输出，将通道的余额分成两半，分别为6毫比属于Fabian和30毫比属于Emma。

最后，Emma点击“停止”停止流媒体视频。 Fabian或Emma现在可以发送最终状态交易以进行结算。最后一笔交易即为结算交易，向Fabian支付所有Emma消费的视频，并退还给Emma注资交易中剩余的资金。

图12-6显示了Emma和Fabian之间的通道以及更新通道余额的承诺交易。

最后，只有两个交易记录在块上：建立通道的注资交易和在两个参与者之间正确分配最终余额的结算交易。

![图12-6 Emma和Fabian之间的支付通道，承诺交易不断的更新通道余额](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1206.png)

图12-6 Emma和Fabian之间的支付通道，承诺交易不断的更新通道余额

### 12.6.3 制造无需信任的通道

我们刚才描述的渠道是有效的，但前提是双方合作，没有任何失败或欺骗企图。我们来看看破坏这个通道的一些场景，并且看看需要什么来解决这些问题：

- 一旦注资交易发生，Emma需要Fabian的签名才能收回自己的任何资金。如果Fabian消失，Emma的资金将被锁定在2/2中，造成实际损失。这个通道一旦建立，如果在双方共同签署至少一个承诺交易之前，有任何一方断开，就会导致资金的流失。

- 当通道正在运行时，Emma可以把Fabian已经会签的任何承诺交易，提交到区块链上。如果她可以发送1号承诺交易，只需支付1秒的视频，为什么还要支付600秒的视频？通道失败是因为Emma可以通过广播对她比较有利的之前的承诺交易来欺骗。

这两个问题都可以用时间锁(timelocks)来解决，下面看看如何使用交易级时间锁（nLocktime）。

除非有退款保证，否则Emma不能冒风险支付到2/2多重签名地址。为了解决这个问题，Emma同时建立了注资交易和退款交易。她只是签名了注资交易，但暂时不发送给任何人。Emma只将退款交易传送给Fabian，并获得他的签名。

退款交易作为第一个承诺交易，其时间锁规定了通道生命的上限。在这种情况下，Emma可以将nLocktime设置为30天或将来的第4320个区块。所有后续承诺交易必须具有较短的时间锁，以便在退款交易之前能把它们兑换。

现在，Emma已经有一个完全签署的退款交易，她可以自信地发送签署过的注资交易，因为她知道最终可以在时间到期后赎回退款交易，即使Fabian消失也不会有问题。

在通道生命中双方交换的每一个承诺交易都会被时间锁锁进未来的时间点。但是每个承诺交易的延迟时间会稍短一点，因此最近的承诺可以在先前的承诺失效之前兑现。由于nLocktime，任何一方都只有其时间锁到期后才能成功传播任何承诺交易。如果一切顺利，他们将协商并通过结算交易正常关闭通道，这样就无需发送中间的承诺交易了。如果发生意外，则可以传播最近的承诺交易进行账户结算，并使以前的所有承诺交易都失效。

例如，如果1号承诺交易被时间锁锁定到未来的第4320个区块，则2号承诺交易被时间锁锁定到未来的4319个块。就是说在1号承诺交易变为有效之前还有600个区块时，600号承诺交易就可以被花费了。

图12-7显示每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费

![图12-7. 每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费 ](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1207.png)

图12-7  每个承诺交易设置较短的时间锁，允许在它在之前的承诺变为有效前被花费

每个后续承诺交易必须具有较短的时间锁，以便可以在上一个承诺交易和退款交易之前进行广播。提前广播承诺的能力可以确保只有它最先能够花费资金输出，并阻止任何其他承诺交易通过花费输出实现兑换。比特币区块链提供的担保，即防止双重支出和强制执行时间锁，有效地允许每个承诺交易废止其上一个承诺交易。

状态通道使用时间锁跨时间维度强制执行智能合约。在这个例子中，我们看到时间维度如何保证最近的承诺交易必须在任何之前的承诺之前先行有效。所以，才可以先发送最近的承诺交易，花费输入，并且使先前的承诺交易无效。执行绝对时间锁的智能合约可以防止其中任何一方的欺骗。实现这个只需要绝对的交易级时间锁（nLocktime）。接下来，我们将看到如何使用脚本级时间锁，CHECKLOCKTIMEVERIFY和CHECKSEQUENCEVERIFY来构建更灵活，有用和复杂的状态通道。

2015年，阿根廷的一个开发团队将第一种单向支付渠道作为视频流应用的原型进行了演示。你可以在[streamsium.io](https://streamium.io/)看到它。

时间锁并不是使之前的承诺交易无效的唯一方法。在接下来的章节中，我们将看到如何使用撤销密钥来实现相同的结果。时间锁是有效的，但其有两个明显的缺点。在通道首次打开时建立最大时间锁，这限制了通道的使用寿命。更糟糕的是，允许通道长时间保留，和如果其中一位参与者提前关闭通道需要等待很长时间才能退款，它们迫使通道要在这二者之间实现一种平衡。例如，如果退款时间设置为30天，那么就是允许通道保持开放30天，如果其中一方立即消失，则另一方必须等待30天才能退款。终点设置越远，退款时间越远。

第二个问题是，由于每个后续的承诺交易必须缩短时间锁，所以在双方之间可以交换的承诺交易数量有明确的限制。例如，一个30天的通道，设置了位于未来第4320个区块的时间锁，在必须被关闭前这段时间只能容纳4320个承诺交易。将时间锁承诺交易的间隔设置为1个区块存在风险。如果将承诺交易之间的时间锁设置为1个区块，开发者会给通道参与者带来了非常高的负担，参与者必须保持警惕，保持在线并监视，并随时准备传送正确的承诺交易。

现在我们了解如何使用时间锁来使先前的承诺无效，我们可以看到协商关闭通道和通过广播承诺交易单方面关闭通道之间的区别。所有承诺交易都是时间锁定的，因为广播承诺交易总是要等待时间锁到期。但是，如果双方同意最后的余额是多少，并且知道双方都持有最终使该余额成为现实的承诺交易，那么他们就可以构建一个结算交易，而不需要代表相同余额的时间戳。在协商关闭中，任一方都接受最近的承诺交易，并建立一个各方面完全相同的结算交易，唯一差别就是它省略了时间锁。双方都可以签署这笔结算交易，因为知道无法作弊以得到更多的余额。通过协商签署和发送结算交易，可以关闭通道并立即兑换余额。最差的情况下，当事人之一可能是卑鄙小人，拒绝合作，强迫另一方单方面关闭最近的承诺交易。但是如果他们这样做，他们也必须一直等待他们的资金。

### 12.6.4 不对称可撤销承诺

处理先前承诺状态的更好方法是明确撤销它们。但是，这不容易实现。比特币的一个关键特征是，一旦交易有效，它一直有效，不会过期。取消交易的唯一方法是在交易被挖矿前用另一笔交易双重支出它的输入。这就是为什么我们在上述简单支付通道示例中使用时间锁，以确保最新的承诺交易可以在旧承诺生效之前被花费。然而，把承诺在时间上排序造成了许多限制，使得支付通道难以使用。

虽说一个交易无法取消，但是它可以被构造成无法再使用的样子。我们这样做的方法是通过给予每一方一个撤销密钥，如果对方试图欺骗，可以用来进行惩罚。撤销先前承诺交易的这种机制首先被作为闪电网络的一部分提出。

为了解释撤销密钥，我们将在由Hitesh和Irene经营的两个交易所之间构建一个更加复杂的支付通道。 Hitesh和Irene分别在印度和美国运营比特币交易所。 Hitesh的印度交易所的客户经常向Irene的美国交易所的客户发送付款，反之亦然。目前，这些交易发生在比特币链上，但这需要支付交易费还要等待几个区块进行确认。在交易所之间设置支付通道将大大降低成本并加快交易流程。

Hitesh和Irene通过合作建立注资交易来启动通道，每人向通道注资5个比特币。初始余额为Hitesh有5比特币且Irene有5比特币。注资交易将通道状态锁定在2/2多重签名中，就像在简单支付通道的例子中一样。

注资交易可能有一个或多个输入（加起来5个比特币或更多）来自Hitesh，以及Irene的一个或多个输入（同样加起来5个比特币或更多）。为了足够支付交易费用，输入必须略微超过通道容量。该交易有一个输出，将总共10个比特币锁定到由Hitesh和Irene控制的2/2多重地址中。如果他们的输入超过他们需要的金额，注资交易也可能有一个或多个输出将找零返回给Hitesh和Irene。这是由双方提供和签署的输入形成的单一交易。在发送之前，必须合作构建并由各方签署。

接着，Hitesh和Irene创建了两个*不对称的asymmetric*承诺交易，而不是创建一个双方都签署的单一承诺交易。

Hitesh有一个带有两个输出的承诺交易。第一个输出是*立即*支付欠Irene的5比特币。第二个输出是支付欠Hitesh自己的5比特币，但条件是只有在1000个区块的时间锁之后。交易输出如下所示：

```
Input: 2-of-2 funding output, signed by Irene

Output 0 <5 bitcoin>:
    <Irene's Public Key> CHECKSIG

Output 1:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key> CHECKSIG
```

Irene也有带有两个输出的不同的承诺交易。第一个输出支付欠Hitesh的5比特币。 第二个输出支付给欠Irene自己的5比特币，但同样必须经过1000个区块的时间锁。 Irene持有的承诺交易（由Hitesh签署）看起来像这样：

```
Input: 2-of-2 funding output, signed by Hitesh

Output 0<5 bitcoin>:
    <Hitesh's Public Key> CHECKSIG

Output 1:
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Irene's Public Key> CHECKSIG
```

这样一来，双方各有一笔承诺交易，可以花费2/2的资金输出。该承诺交易的输入是由*对方*署的。在任何时候，持有承诺交易的一方都可以签字（完成2/2签名）并进行广播。然而，如果他们广播承诺交易，承诺交易会立即支付对方，而他们自己的资金则必须等待时间锁到期。通过强制延迟兑换其中一方的输出，我们可以做到让各方在选择单方面广播承诺交易时处于轻微的不利地位。 但是单靠时间延迟还不足以鼓励公平的行为。

下图12-8显示两个不对称承诺交易，其中承诺持有人的输出被延迟 

![图12-8显示两个不对称承诺交易，其中承诺持有人的输出被延迟](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_1208.png)

图12-8 显示两个不对称承诺交易，其中承诺持有人的输出被延迟

现在我们介绍这个方案的最后一个要素：一个防止作弊者广播过期承诺的撤销密钥，它允许被欺诈的一方通过占有通道的所有余额来惩罚骗子。

撤销密钥由两个密语组成，每个密语由每个通道参与者独立生成。它类似于2/2的多重签名，使用椭圆曲线算法构造。虽然双方都知道撤销公钥，但其实每一方只知道撤销密钥的一半。

在每一轮交易中，双方都将其撤销密语的一半透露给另一方，从而使另一方（现在双方都有）在广播此撤销的交易时，可以要求获得惩罚输出。

每个承诺交易都有一个“延迟”的输出，该输出的兑换脚本允许一方在1000个区块后兑换它，或者另一方如果拥有撤销密钥也可兑换它。

所以当Hitesh为Irene签署承诺交易时，他将在1000个区块之后把第二个输出定支付给自己，或者支付给撤销公钥（他只知道其中一半的密语）。Hitesh构建了这个交易，他只会在准备改变通道状态，并希望撤销这一承诺交易时，才会把半个撤销密语透露给Irene。

第二个输出脚本如下所示：

```
Output 0 <5 bitcoin>:
    <Irene's Public Key> CHECKSIG

Output 1 <5 bitcoin>:
IF
    # Revocation penalty output
    <Revocation Public Key>
ELSE
    <1000 blocks>
    CHECKSEQUENCEVERIFY
    DROP
    <Hitesh's Public Key>
ENDIF
CHECKSIG
```

Irene可以自信地签署这笔交易，因为一旦被发送，它将立即首先支付欠她的款。Hitesh持有交易，但知道如果自己单方面关闭通道发送交易，将不得不等待1000个区块才能获得付款。

当通道进入下一个状态时，Hitesh必须在Irene同意签署下一个承诺交易之前*撤销*此承诺交易。要做到这一点，他所要做的就是将*撤销密语*发送给Irene。一旦Irene拥有这一承诺的两个半部分撤销密语，她就可以自信地签署下一个承诺。她知道，如果Hitesh试图通过发布先前的承诺交易来作弊，她可以使用撤销密钥来兑换Hitesh的延迟输出。*如果Hitesh作弊，Irene会得到两部分输出。*同时，Hitesh只有该撤销公钥的一半撤销密语，并且在1000个区块之前无法兑换输出。Irene可以在1000个区块过去之前兑换输出并惩罚Hitesh。

撤销协议是双边的，这意味着在每一轮中，随着通道状态的推进，双方交换新的承诺，并且交换之前承诺的撤销密语，签署双方新的承诺交易。当他们接受新的状态时，他们通过给予对方必要的撤销密语来惩罚任何作弊行为，使先前的状态不可用。

我们来看一个它是如何工作的。Irene的一个客户希望向Hitesh的一个客户发送2比特币。要通过通道传输2比特币，Hitesh和Irene必须更新通道状态以反映新的余额。他们将提交一个新的状态（状态号2），通道的10个比特币被分割，7个比特币属于Hitesh和3个比特币属于Irene。为了更新通道的状态，他们将各自创建反映新通道余额的新承诺交易。

如上述内容所说，这些承诺交易是不对称的，所以每一方所持的承诺交易都迫使他们等待兑换。至关重要的是，在签署新的承诺交易之前，他们必须首先交换撤销密语以使先前的承诺无效。在这种情况下，Hitesh的利益与通道的真实状态是一致的，因此他没有理由广播先前的状态。然而，对于Irene来说，状态号1中留给她的余额比状态2中的更高。当Irene把她以前的承诺交易（状态号1）的撤销密语提供给Hitesh时，她实际上放弃了恢复通道状态到前一状态而从中获益的权利。因为有了撤销密语，Hitesh可以毫不迟疑地兑换先前承诺交易的两个输出。也就是说一旦Irene广播先前的状态，Hitesh可以行使他的权利，占有所有的输出。

重要的是，撤销不会自动发生。虽然Hitesh有能力惩罚Irene的作弊行为，但他必须认真观察区块链中作弊的迹象。如果他看到先前的承诺交易广播，他有1000个区块时间采取行动，并使用撤销密语来阻止Irene的欺骗行为，并占有所有余额，也就是全部10比特币来惩罚她。

带有相对时间锁（CSV）的不对称可撤销承诺是实现支付通道的更好方法，也是区块链技术非常重要的创新。通过这种结构，通道可以无限期地保持开放，并且可以拥有数十亿的中间承诺交易。在闪电网络的原型实现中，承诺状态由48位索引识别，允许在任何单个通道中有超过281万亿（2.8×10<sup>14</sup>）个状态转换！

### 12.6.5 哈希时间锁合约（HTLC）

支付通道可以通过特殊类型的智能合约进一步扩展，该合约允许参与者将资金用于可兑换的有到期时间的密钥。此功能称为*哈希时间锁定合约Hash Time Lock Contract*或*HTLC*，用于双向和可路由的支付通道。

首先我们来解释HTLC的“哈希”部分。 要创建一个HTLC，预期的收款人将首先创建一个密钥（secret）R。他们然后计算这个R的哈希H：

```
H = Hash(R)
```

这步产生可以包含在输出的锁定脚本中的哈希H。 知道秘密的任何人可以用它来兑换输出。 秘密R也被称为哈希函数的*前图像*。 前图像就是用作哈希函数输入的数据。

HTLC的第二部分是“时间锁”组件。 如果秘密没有被透露，HTLC的付款人可以在一段时间后得到“退款”。 这是通过使用绝对时间锁CHECKLOCKTIMEVERIFY来实现的。实现HTLC的脚本可能如下所示：

```
IF
   # Payment if you have the secret R
   HASH160 <H> EQUALVERIFY
ELSE
  # Refund after timeout.
  <locktime>
  CHECKLOCKTIMEVERIFY DROP
  <Payee Pubic Key> CHECKSIG
ENDIF


```

任何知道可以让哈希等于H的对应秘密R的人，可以通过行使IF语句的第一个子句来兑换该输出。

如果秘密没有被透露，HTLC中写明了，在一定数量的块之后，收款人可以使用IF语句中的第二个子句申请退款。

这是HTLC的基本实现。 任何 拥有秘密R的人都可以兑换这种类型的HTLC。通过对脚本进行微调，HTLC可以采用许多不同的形式。 例如，在第一个子句中添加一个CHECKSIG运算符和一个公钥来限制将哈希值兑换成一个指定的收件人，这个人必须知道秘密R.

## 12.7可路由的支付通道（闪电网络）

闪电网络是一种端到端连接的双向支付通道的可路由网络。这样的网络可以允许任何参与者穿过一个通道路由到另一个通道进行支付，而不需要信任任何中间人。闪电网络由Joseph Poon和Thadeus Dryja于2015年2月首次描述，其基础是许多其他人提出和阐述的支付通道概念。

“闪电网络”是指路由支付通道网络的具体设计，现已由至少五个不同的开源团队实施。这些的独立实施是由“闪电技术基础”（BOLT）论文中描述的一组互通性标准进行协作。

闪电网络的原型实施已经由几个团队发布。现在，这些实现只能在testnet上运行，因为它们使用segwit，还没有在比特币区块主链（mainnet）上激活。

闪电网络是实现可路由支付通道的一种可能方式。还有其他几种旨在实现类似目标的设计，如Teechan和Tumblebit。

### 12.7.1闪电网络示例

让我们看看它是如何工作的。

在这个例子中，我们有五个参与者：Alice, Bob, Carol, Diana, and Eric。这五名参与者已经彼此之间开设了支付通道。Alice和Bob有支付通道。Bob连接Carol，Carol连接到Diana，Diana连接Eric。为了简单起见，我们假设每个通道每个参与者都注资2个比特币资金，每个通道的总容量为4个比特币。

下图12-9显示一系列通过双向支付的通道连接在一起形成闪电网络以支持一笔从Alice到Eric的付款 展示了闪电网络中五名参与者，通过双向支付通道连接，可从Alice付款到Eric（路由支付通道（闪电网络））。

[![图12-9显示一系列通过双向支付的通道连接在一起形成闪电网络以支持一笔从Alice到Eric的付款](https://camo.githubusercontent.com/1f2a5c1dbf6f8c03097444f78075ff7321f7dc7c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d656466393061356365666635613336652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/1f2a5c1dbf6f8c03097444f78075ff7321f7dc7c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d656466393061356365666635613336652e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

Alice想要支付给Eric1个比特币。 不过，Alice并未通过支付通道连接到Eric。 创建支付通道需要资金交易，而这笔交易必须首先提交给比特币区块链。 Alice不想打开一个新的支付通道并支出更多的手续费。 有没有办法间接支付Eric？

下图12-10 显示了通过在连接各方参与者的支付通道上通过一系列HTLC承诺将付款从Alice路由到Eric的逐步过程。

[![图12-10 ](https://camo.githubusercontent.com/6c36ebad622e0fcbabea4123ce1339bb0b1a3eb0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d346137363030663431656538343939612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)](https://camo.githubusercontent.com/6c36ebad622e0fcbabea4123ce1339bb0b1a3eb0/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313738353935392d346137363030663431656538343939612e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

Alice正在运行闪电网络（LN）节点，该节点正在跟踪其向Bob的付费通道，并且能够发现支付通道之间的路由。Alice的LN节点还具有通过互联网连接到Eric的LN节点的能力。 Eric的LN节点使用随机数生成器创建一个秘密R。Eric的节点没有向任何人泄漏这个秘密。相反，Eric的节点计算秘密R对应的哈希H，并将此哈希发送到Alice的节点（请参阅图12-10步骤1）。

现在Alice的LN节点构建了Alice的LN节点和Eric的LN节点之间的路由。所使用的路由算法将在后面进行更详细的解释，但现在我们假设Alice节点可以找到一个高效的路由。

然后，Alice的节点构造一个HTLC，支付到哈希H，具有10个区块时间的退款超时（当前块+10），数量为1.003比特币（参见图12-10的步骤2）。额外的0.003将用于补偿参与此支付路由的中间节点。Alice将此HTLC提供给Bob，从和Bob之间的通道余额中扣除1.003比特币，并将其提交给HTLC。 该HTLC具有以下含义：“如果Bob知道秘密，Alice将其通道余额的1.003支付给Bob，或者如果超过10个区块时间后，则退还入Alice的余额”。 Alice和Bob之间的通道余额现在由承诺交易表示，其中有三个输出：Bob的2比特币余额，Alice的0.997比特币余额，Alice的HTLC中承诺的1.003比特币。承诺在HTLC中的金额从Alice的余额中被减去。

Bob现在有一个承诺，如果他能够在接下来的10个区块生产时间内获得秘密R，他可以获取Alice锁定的1.003。手上有了这一承诺，Bob的节点在和Carol的支付通道上构建了一个HTLC。Bob的HTLC提交1.002比特币到哈希H共9个区块时间，这个HTLC中如果Carol有秘密R她可以兑换（参见图12-10步骤3）。Bob知道，如果Carol要获取他的HTLC，她必须出示秘密R。如果Bob在9个区块的时间内有R，他可以用它来获取Alice的HTLC给自己。通过承诺自己的通道余额9个区块的时间，他也赚了0.001比特币。如果Carol无法获取他的HTLC，并且他也无法获取Alice的HTLC，那么一切都将恢复到以前的通道余额，没有人会亏损。 Bob和Carol之间的通道余额现在是：2比特币给Carol，0.998给Bob，1.002由Bob承诺给HTLC。

Carol现在有一个承诺，如果她在接下来的9个区块时间内获得R，她可以获取Bob的锁定1.002比特币。现在她可以在她与Diana的通道上构建HTLC承诺。她提交了一个1.001比特币的HTLC到哈希H，共计8个区块时间，如果Diana有秘密R ，她就可以兑换（参见图12-10步骤4）。从Carol的角度来看，如果能够实现，她就可以获得的0.001比特币，否则也没有失去任何东西。她提交给Diana的HTLC，只有在R被泄漏的情况下才可行，到那时候她可以从Bob那里索取HTLC。Carol和Diana之间的通道余额现在是：2给Diana，0.999给Carol，1.001由Carol承诺给HTLC。

最后，Diana可以提供给Eric一个HTLC，承诺1比特币，7个区块时间，到哈希H（参见图12-10的步骤5）。Diana与Eric之间的通道余额现在是：2给Eric，1给Diana，1由Diana承诺给HTLC。

然而，在这条路上，Eric拥有秘密R，他可以获取Diana提供的HTLC。他将R发送给Diana，并获取1个比特币，添加到他的通道余额中（参见图12-10的步骤6）。通道平衡现在是：1给Diana，3给Eric。

现在，Diana有秘密R，因此，她现在可以获取来自Carol的HTLC。Diana将R发送给Carol，并将1.001比特币添加到其通道余额中（参见图12-10的步骤7。现在Carol与Diana之间的通道余额是：0.999给Carol，3.001给Diana。Diana已经“赚了”参与这个付款路线0.001比特币。

通过路由回传，秘密R允许每个参与者获取未完成的HTLC。Carol从Bob那里获取1.002个比特币，将他们通道余额设为：0.998给Bob，3.002给Carol（参见闪电网络步骤8）。最后，Bob获取来自Alice的HTLC（参见闪电网络步骤9）。他们的通道余额更新为：0.997给Alice，3.003给Bob。

在没有向Eric打开通道的情况下，Alice已经支付了Eric 1比特币。付款路线中的中间方不必要互相信任。在他们的通道内做一个短时间的资金承诺，他们可以赚取一小笔费用，唯一的风险是，如果通道关闭或路由付款失败，退款有段短短的延迟时间。

### 12.7.2闪电网络传输和路由

LN节点之间的所有通信都是点对点加密的。 另外，节点有一个长期公钥，[它们用作标识符并且彼此认证对方](http://bit.ly/2r5TACm)。

每当节点希望向另一个节点发送支付时，它必须首先通过连接具有足够容量的支付通道来构建通过网络的路径。节点宣传路由信息，包括他们已经打开了什么通道，每个通道拥有多少容量，以及他们收取多少路由支付费用。路由信息可以以各种方式共享，并且随着闪电网络技术的进步，不同的路由协议可能会出现。一些闪电网络实施使用IRC协议作为节点宣布路由信息的一种方便的机制。路由发现的另一种实现方式是使用P2P模型，其中节点将通道宣传传播给他们的对等体，在“洪水泛滥”模型中，这类似于比特币传播交易的方法。未来的计划包括一个名为[Flare](http://bit.ly/2r5TACm)的建议，它是一种具有本地节点“邻居”和较长距离的信标节点的混合路由模型。

在我们前面的例子中，Alice的节点使用这些路由发现机制之一来查找将她的节点连接到Eric的节点的一个或多个路径。一旦Alice的节点构建了路径，她将通过网络初始化该路径，传播一系列加密和嵌套的指令来连接每个相邻的支付通道。

重要的是，这个路径只有Alice的节点才知道。付款路线上的所有其他参与者只能看到相邻的节点。从Carol的角度来看，这看起来像是从Bob到Diana的付款。 Carol不知道Bob实际上是中继转发Alice的汇款。她也不知道Diana将会向Eric中继转发付款。

这是闪电网络的一个重要特征，因为它确保了付款的隐私，并且使得很难应用监视，审查或黑名单。但是，Alice如何建立这种付款途径，而不向中间节点透露任何内容？

闪电网络实现了一种基于称为Sphinx的方案的洋葱路由协议。该路由协议确保支付发送者可以通过闪电网络构建和通信路径，使得：

- 中间节点可以验证和解密其部分路由信息，并找到下一跳。
- 除了上一跳和下一跳，他们不能了解作为路径一部分的任何其他节点。
- 他们无法识别支付路径的长度，或者他们自己在该路径中的位置。
- 路径的每个部分被加密，使得网络级攻击者不能将来自路径的不同部分的数据包彼此关联。
- 不同于Tor（互联网上的洋葱路由匿名协议），没有可以被监视的“退出节点”。付款不需要传输到比特币区块链，节点只是更新通道余额。

使用这种洋葱路由协议，Alice将路径的每个元素包裹在一层加密中，从尾端开始倒过来运算。她用Eric的公钥加密了Eric的消息。该消息包裹在加密到Diana的消息中，将Eric标识为下一个收件人。给Diana的消息包裹在加密到Carol的公钥的消息中，并将Diana识别为下一个收件人。对Carol的消息被Bob的密钥加密。这样一来，Alice已经构建了这个加密的多层“洋葱”的消息。她发送给Bob，他只能解密和解开外层。在里面，Bob发现一封给Carol的消息，他可以转发给Carol，但不能自己破译。按照路径，消息被转发，解密，转发等，一路到Eric那里。每个参与者只知道各自这一跳的前一个和下一个节点。

路径的每个元素包含承载于HTLC的必须扩展到下一跳的信息，HTLC中的要发送的数量，要包括的费用以及CLTV锁定到期时间（以块为单位）。随着路由信息的传播，节点将HTLC承诺转发到下一跳。

在这一点上，您可能会想知道节点怎么知道路径的长度及其在该路径中的位置。毕竟，他们收到一个消息，并将其转发到下一跳。难道它不会将路径缩短，或者允许他们推断出路径大小和位置？为了防止这种情况，路径总是固定在20跳，并用随机数据填充。每个节点都会看到下一跳和一个要转发的固定长度的加密消息。只有最终的收件人看得到没有下一跳。对于其他人来说，似乎总是有20多跳要走。

### 12.7.3闪电网络优势

闪电网络是第二层路由技术。它可以应用于支持一些基本功能的任何区块链，如多重签名交易，时间锁定和基本的智能合约。

如果闪电网络搭建在在比特币网络之上，则比特币网络可以大大提高容量，隐私性，粒度和速度，而不会牺牲无中介机构的无信任操作原则：

**隐私** 闪电网络付款比比特币区块链的付款更私密，因为它们不是公开的。虽然路由中的参与者可以看到在其通道上传播的付款，但他们并不知道发件人或收件人。

**流动性** 闪电网络使得在比特币上应用监视和黑名单变得更加困难，从而增加了货币的流动性。

**速度** 使用闪电网络的比特币交易将以毫秒为单位，而不是分钟，因为HTLC在不用提交交易到区块上的情况下被结算。

**粒度** 闪电网络可以使支付至少与比特币“灰尘”限制一样小，甚至更小。一些建议允许子聪级增量（subsatoshi increments）。

**容量** 闪电网络将比特币系统的容量提高了几个数量级。每秒可以通过闪电网络路由的付费数量没有具体上限，因为它仅取决于每个节点的容量和速度。

**无信任操作**闪电网络在不需要互相信任就可以作为对等体使用的节点之间使用比特币交易。因此，闪电网络保留了比特币系统的原理，同时显著扩大了其操作参数。

当然，如前所述，闪电网络协议不是实现路由支付通道的唯一方法。其他被提出的系统包括Tumblebit和Teechan。然而，在这个时候，闪电网络已经部署在testnet上了。几个不同的团队已经开发了正在竞争的LN实现，并且正在努力实现一个通用的互操作性标准（称为BOLT）。闪电网络很可能是第一个部署在生产实际中的路由支付通道网络。

## 12.8结论

我们仅研究了几个可以使用比特币区块链作为信任平台构建的新兴应用程序。这些应用程序将比特币的范围扩大到超出付款和超越金融工具的范围，以涵盖许多信任至关重要的其他应用程序。通过去中性化的信任基础，比特币区块链是一个会释放将在各种行业中产生许多革命性应用的平台。

